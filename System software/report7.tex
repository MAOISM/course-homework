\iffalse                             % 块注释
如果要注释一块文字，用\iffalse ... \fi 界定住要
注释的文字。特别提醒：以下设置的次序不能乱，否则
会引发冲突，影响到编译是否成功。
\fi
\documentclass[a4paper,11pt,         % A4纸
               twoside,              % 双面
%              openany               % 新章节在偶数页开始
               ]{article}

%%%%%%%%%% 版面控制 %%%%%%%%%%
\usepackage{indentfirst}             % 首行缩进
\iffalse
\usepackage[%paperwidth=18.4cm, paperheight= 26cm,
            body={14.6true cm,22true cm},
            twosideshift=0 pt,
            %headheight=1.0true cm
            ]{geometry}
\fi
\usepackage[perpage,symbol]{footmisc}% 脚注控制
\usepackage[sf]{titlesec}            % 控制标题
\usepackage{titletoc}                % 控制目录
\usepackage{fancyhdr}                % 页眉页脚
\usepackage{type1cm}                 % 控制字体大小
\usepackage{indentfirst}             % 首行缩进
\usepackage{makeidx}                 % 建立索引
\usepackage{textcomp}                % 千分号等特殊符号
\usepackage{layouts}                 % 打印当前页面格式
\usepackage{bbding}                  % 一些特殊符号
\usepackage{cite}                    % 支持引用
\usepackage[pdfstartview=FitH,
            CJKbookmarks=true,
            bookmarksnumbered=true,
            bookmarksopen=false,
            colorlinks=true, %注释掉此项则交叉引用为彩色边框(将colorlinks和pdfborder 同时注释掉)
            %pdfborder=001,   %注释掉此项则交叉引用为彩色边框
            citecolor=magenta,% magenta , cyan
            linkcolor=black,
            ]{hyperref}       % hyperref 宏包通常要求放在导言区的最后!!!
\usepackage{color,xcolor}            % 支持彩色文本、底色、文本框等
\usepackage{listings}                % 粘贴源代码
\definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\lstloadlanguages{}                  % 所要粘贴代码的编程语言
\lstset{
    language=[AspectJ]Java,
    basicstyle=\footnotesize,
    numbers=left,
    numberstyle= \tiny,
    keywordstyle=\color{keywordcolor}\bfseries, %\underbar,
    identifierstyle=,
    commentstyle=\color{blue} \textit,
    stringstyle=\ttfamily,
    showstringspaces=false,
    extendedchars=false,%
    xleftmargin=1em,
    linewidth=\textwidth,%
}

%%%%%%%%%% 字体支持 %%%%%%%%%%%%
%\usepackage{ccmap}                  % 使pdfLatex生成的文件支持复制等
\usepackage{CJK,CJKnumb,CJKulem}     % 中文支持
\usepackage{times}     % 包括 Times Roman + Helvetica + Courier
%\usepackage{palatino} % 包括 Palatino + Helvetica + Courier
%\usepackage{newcent}  % 包括 New Century Schoolbook + Avant Garde + Courier
%\usepackage{bookman}  % 包括 Bookman + Avant Garde + Courier

%%%%%%%%%% 数学符号公式 %%%%%%%%%%
\usepackage{latexsym}
\usepackage{amsmath}                 % AMS LaTeX 宏包
\usepackage{amssymb}                 % 用来排版漂亮的数学公式
\usepackage{amsbsy}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathrsfs}                % 英文花体字体
\usepackage{bm}                      % 数学公式中的黑斜体
\usepackage{relsize}                 % 调整公式字体大小：\mathsmaller, \mathlarger
\usepackage{caption2}                % 浮动图形和表格标题样式

%%%%%%%%%% 图形支持宏包 %%%%%%%%%%
\ifx\pdfoutput\undefined             % 用latex或pdflatex编译
  \usepackage[dvips]{graphicx}       % 将eps格式的图片放在figures目录下
\else                                % 在setup/format.tex中用以下命令注明路径：
  \usepackage[pdftex]{graphicx}      % \graphicspath{{figures/}}
\fi
%\usepackage{subfigure}
\usepackage{epsfig}                  % 支持eps图像
%\usepackage{picinpar}               % 图表和文字混排宏包
%\usepackage[verbose]{wrapfig}       % 图表和文字混排宏包
%\usepackage{eso-pic}                % 向文档的部分页加n副图形, 可实现水印效果
%\usepackage{eepic}                  % 扩展的绘图支持
%\usepackage{curves}                 % 绘制复杂曲线
%\usepackage{texdraw}                % 增强的绘图工具
%\usepackage{treedoc}                % 树形图绘制
%\usepackage{pictex}                 % 可以画任意的图形
%\usepackage{hyperref}


\makeindex                           % 生成索引
\pagestyle{fancy}                    % 页眉页脚风格
\fancyhf{}                           % 清空当前页眉页脚的默认设置

%%%% 下面的命令重定义页面边距，使其符合中文刊物习惯 %%%%
\addtolength{\topmargin}{-54pt}
\setlength{\oddsidemargin}{0.63cm}  % 3.17cm - 1 inch
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{14.66cm}
\setlength{\textheight}{24.00cm}    % 24.62

%%%% 下面的命令设置行间距与段落间距 %%%%
\linespread{1.4}
% \setlength{\parskip}{1ex}
\setlength{\parskip}{0.5\baselineskip}

%%%%%%%%%% 导入中文环境 %%%%%%%%%%
\AtBeginDocument{\begin{CJK*}{GBK}{song} % 不计中文的空格
\CJKindent                           % 首行缩进两个汉字
\sloppy\CJKspace                     % 中英文混排的断行
\CJKtilde                            % 重新定义~，用~隔开中英文
}
\AtEndDocument{\end{CJK*}}

%%%%%%%%%% 正文 %%%%%%%%%%
\begin{document}

%%%%%%%%%% 一些新定义 %%%%%%%%%%
\newcommand{\song}{\CJKfamily{song}} % 宋体
\newcommand{\hei}{\CJKfamily{hei}}   % 黑体
\newcommand{\fs}{\CJKfamily{fs}}     % 仿宋
\newcommand{\kai}{\CJKfamily{kai}}   % 楷体

%%%%%%%%%% 定理类环境的定义 %%%%%%%%%%
%% 必须在导入中文环境之后
\newtheorem{example}{例}             % 整体编号
\newtheorem{algorithm}{算法}
\newtheorem{theorem}{定理}[section]  % 按 section 编号
\newtheorem{definition}{定义}
\newtheorem{axiom}{公理}
\newtheorem{property}{性质}
\newtheorem{proposition}{命题}
\newtheorem{lemma}{引理}
\newtheorem{corollary}{推论}
\newtheorem{remark}{注解}
\newtheorem{condition}{条件}
\newtheorem{conclusion}{结论}
\newtheorem{assumption}{假设}

%%%%%%%%%% 一些重定义 %%%%%%%%%%
%% 必须在导入中文环境之后
\renewcommand{\contentsname}{目录}     % 将Contents改为目录
\renewcommand{\abstractname}{摘\ \ 要} % 将Abstract改为摘要
\renewcommand{\refname}{参考文献}      % 将References改为参考文献
\renewcommand{\indexname}{索引}
\renewcommand{\figurename}{图}
\renewcommand{\tablename}{表}
\renewcommand{\appendixname}{附录}
\renewcommand{\proofname}{\hei 证明}
\renewcommand{\algorithm}{\hei 算法}
\renewcommand{\today}{\number\year 年 \number\month 月 \number\day 日}

%%%%%%%%%% 重定义字号命令 %%%%%%%%%%
\newcommand{\yihao}{\fontsize{26pt}{36pt}\selectfont}       % 一号, 1.4倍行距
\newcommand{\erhao}{\fontsize{22pt}{28pt}\selectfont}       % 二号, 1.25倍行距
\newcommand{\xiaoer}{\fontsize{18pt}{18pt}\selectfont}      % 小二, 单倍行距
\newcommand{\sanhao}{\fontsize{16pt}{24pt}\selectfont}      % 三号, 1.5倍行距
\newcommand{\xiaosan}{\fontsize{15pt}{22pt}\selectfont}     % 小三, 1.5倍行距
\newcommand{\sihao}{\fontsize{14pt}{21pt}\selectfont}       % 四号, 1.5倍行距
\newcommand{\bansi}{\fontsize{13pt}{19.5pt}\selectfont}     % 半四, 1.5倍行距
\newcommand{\xiaosi}{\fontsize{12pt}{18pt}\selectfont}      % 小四, 1.5倍行距
\newcommand{\dawu}{\fontsize{11pt}{11pt}\selectfont}        % 大五, 单倍行距
\newcommand{\wuhao}{\fontsize{10.5pt}{10.5pt}\selectfont}   % 五号, 单倍行距


%%%%%%%%%% 页眉和页脚的设置 %%%%%%%%%%
\lhead{清华大学软件学院计算机系统软件（2）}
\rhead{}
\lfoot{}
\rfoot{~\thepage~}

%%%%%%%%%% 论文标题、作者等 %%%%%%%%%%
\title{\hei{HSQLDB 的恢复机制分析}}
\author{文庆福 \\ 2011013239 thssvince@163.com  \\
   \xiaosi  清华大学软件学院11班\\
}
\date{\today}                % 日期
\maketitle                           % 生成标题
\thispagestyle{empty}                % 首页无页眉页脚
\tableofcontents
\newpage


%%%%%%%%%% section %%%%%%%%%%
\section{实验简介}
\subsection{实验背景}
恢复机制是数据库系统必不可少的组成部分, 它负责将数据库恢复到故障发生前的某个一致的状态。我们曾分析过 HSQLDB 中的文件存储结构, 这些文件不仅提供了数据的磁盘存储, 还提供了数据库恢复的支持。\\\indent
本次实验，我们将分析 HSQLDB 的恢复机制，研究其日志记录系统及基于日志恢复的过程。

\subsection{实验环境}
\begin{itemize}
 \item 操作系统：Windows 8 企业版
 \item JDK: OpenJDK 7（64-Bit）
 \item HSQLDB: 2.3.1
 \item IDE: Eclipse Standard(Kepler Service Release 1)
\end{itemize}
\section{HSQLDB 的数据恢复流程}
\subsection{记录日志}
HSQLDB 会将数据的插入、删除、提交、回滚等操作都记录在 log 文件中。对于 autocommit 的，每条插入、删除语句之后，都会额外记录一个 COMMIT 操作。而对于非 autocommit 的，只有在执行 commit 之后，才会将这些操作记录在 log 文件中。
\subsection{恢复流程}
当打开数据库时，如果数据库是已修改状态，HSQLDB 就会处理 log 文件，按照 log 文件中记录到操作顺序执行。\\\indent
当执行完成后，会调用 checkpoint 方法将数据写回，同时整理 script 文件。
\section{HSQLDB 的日志与恢复}
HSQLDB 中读写数据库日志的类主要包括org.hsqldb.scriptio.ScriptWriterText、 org.hsqldb.scriptio.ScriptReaderText、org.hsqldb.persist.Log 和 org.hsqldb.persist.Logger 。\\\indent
其中，ScriptWriterText 类用于处理所有的 script 和 log，提供基本的写入操作，可以以脚本命令的形式保存当前数据库的快照。 而ScriptReaderText 类是用于读取所有 script 和 log，提供基本的读入操作。\\\indent
Log 类主要就是用来管理数据库文件的，包括.properties、.script、.data、 .backup、.log file 和 .lobs 文件。它使用 ScriptWriterText 类完成日志和脚本的写入，使用 ScriptReaderText 类完成日志和脚本的读取。除此之外，还提供了恢复等方法。\\\indent
Logger 类则是高层次封装的接口，HSQLDB 中的各种日志的行为都是通过Logger 类操作的。
\subsection{ScriptWriterText 类}
ScriptWriterText 类继承自 ScriptWriterTextBase 类，ScriptWriterTextBase 是用于数据写入操作的，就不做过多分析了。下面我们主要分析下 ScriptWriterText 类中的两个方法 writeRow 和 writeRowOutToFile。
\begin{itemize}
\item writeRow
\begin{lstlisting}
public void writeRow(Session session, Row row,
                     Table table) throws IOException {
    schemaToLog = table.getName().schema;
    writeSessionIdAndSchema(session);
    rowOut.reset();
    ((RowOutputTextLog) rowOut).setMode(RowOutputTextLog.MODE_INSERT);
    rowOut.write(BYTES_INSERT_INTO);
    rowOut.writeString(table.getName().statementName);
    rowOut.write(BYTES_VALUES);
    rowOut.writeData(row, table.getColumnTypes());
    rowOut.write(BYTES_TERM);
    rowOut.write(BYTES_LINE_SEP);
    writeRowOutToFile();
}\end{lstlisting}
在上面函数中首先调用 writeSessionIdAndSchema 将 session 和 schema 写入，格式化是 /*C session\_id*/SET SCHEMA schema\_name，接下来依次写入 INSERT INTO、表名、VALUES，最终会调用 writeRowOutToFile 方法写入 log 文件。
\item writeRowOutToFile
\begin{lstlisting}
void writeRowOutToFile() throws IOException {
    synchronized (fileStreamOut) {
        fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
        byteCount += rowOut.size();
        lineCount++;
    }
}\end{lstlisting}
首先，对流对象做互斥操作，显然文件 IO 是不能异步进行的。然后调用流写入方法 write 将数据写入，并更新写入的字节数和行数。
\end{itemize}
\subsection{ScriptReaderText 类}
ScriptReaderText 类主要用来读取 script 文件和 log 文件。下面也分析下它的主要方法：
\begin{itemize}
\item readLoggedStatement
\begin{lstlisting}
public boolean readLoggedStatement (Session session) {
    if (! sessionChanged ) {
        String s;
        try {
            s = dataStreamIn .readLine ();
        } catch ( EOFException e) {
            return false ;
        } catch ( IOException e) {
            throw Error.error(e, ErrorCode .FILE_IO_ERROR , null );
        }
        lineCount ++;
        statement = StringConverter . unicodeStringToString (s);
        if ( statement == null ) {
            return false ;
        }
    }
    processStatement (session );
    return true ;
}\end{lstlisting}
这个方法在恢复时会用到，顾名思义，用于读取日志中的语句。第 2-16 行将读取日志中的一行，并在第 17 行交给 processStatement 方法处理。
\item processStatement
\begin{lstlisting}
void processStatement (Session session) {
    ......
    sessionChanged = false ;
    rowIn. setSource ( statement );
    statementType = rowIn. getStatementType ();
    if ( statementType == ANY_STATEMENT ) {
        ......
    } else if ( statementType == COMMIT_STATEMENT ) {
        ......
    } else if ( statementType == SET_SCHEMA_STATEMENT ) {
        ......
    }
    String name = rowIn. getTableName ();
    ......
    Type [] colTypes;
    if ( statementType == INSERT_STATEMENT ) {
        ......
    }
    try {
        rowData = rowIn.readData(colTypes );
    } catch ( IOException e) {
        throw Error.error(e, ErrorCode .FILE_IO_ERROR , null );
    }
}\end{lstlisting}
这与 SQL 语句的解析是相似的，首先判断语句类型，对于未知类型、COMMIT 及 SET SCHEMA 语句，直接返回。对于其他语句，填充相应的数据域，包括表名，列类型，数据等。
\item readDLL
\begin{lstlisting}
protected void readDDL(Session session) {
    for (; readLoggedStatement (session ); ) {
        Statement cs = null ;
        Result result = null ;
        if (rowIn. getStatementType () == INSERT_STATEMENT ) {
            isInsert = true ;
            break ;
        }
        try {
            cs = session. compileStatement ( statement );
            result = session. executeCompiledStatement (cs ,
            ValuePool . emptyObjectArray );
        } catch ( HsqlException e) {
            result = Result. newErrorResult (e);
        }
        if (result.isError ()) {
            ......
        }
    }
}\end{lstlisting}
readDLL 方法用于读取并执行 script 文件中的 DDL 语句。\\
第 2-19 行将调用 readLoggedStatement 方法不断读取语句。\\
第 5 行判断是否是插入语句，如果是，则退出。（script 文件由 DDL 语 和 INSERT 语句与 SET SCHEMA语句两部分构成。）\\
第 9-15 行将编译、执行读到的一条语句，这一过程已在之前的实验中进行过详细的分析。
\item readExistingData
\begin{lstlisting}
protected void readExistingData (Session session) {
    try {
        String tablename = null ;
        ......
        for (; isInsert || readLoggedStatement (session );
                isInsert = false ) {
            if ( statementType == SET_SCHEMA_STATEMENT ) {
                session. setSchema ( currentSchema );
                continue ;
            } else if ( statementType == INSERT_STATEMENT ) {
                if (! rowIn. getTableName (). equals( tablename )) {
                tablename = rowIn. getTableName ();
                String schema = session. getSchemaName ( currentSchema );
                currentTable =
                    database. schemaManager . getUserTable (session ,
                        tablename , schema );
                currentStore =
                    database. persistentStoreCollection .getStore(
                        currentTable );
                }
                currentTable . insertFromScript (session , currentStore ,
                    rowData );
            } else {
                throw Error.error( ErrorCode . ERROR_IN_SCRIPT_FILE ,
                    statement );
            }
        }
        ......
    } catch ( Throwable t) {
        ......
    }
}\end{lstlisting}
\end{itemize}
readExistingData 方法用于从 script 文件中读取并向数据库中插入数据。\\
这里的处理方法与 readDLL 方法类似：不断调用 readLoggedStatement 方法读取语句，如果是 SET SCHEMA 语句，则调用 session 对象的 setSchema方法设置上下文的 Schema；如果是插入语句，则在设置表名、Schema 后，获取表对象，然后调用表对象的 insertFromScript 方法插入数据。
\subsection{Log 类}
Log 类位于 org.hsqldb.persist 包中，因此该类不仅处理记录 log ，也负责进行一些和数据存储有关的操作。\\\indent
对于记录 log，比较简单，例如对于插入语句：
\begin{lstlisting}
void writeInsertStatement (Session session , Row row , Table t) {
    try {
        dbLogWriter . writeInsertStatement (session , row , t);
    } catch ( IOException e) {
        throw Error.error( ErrorCode .FILE_IO_ERROR , logFileName );
    }
    if ( maxLogSize > 0 && dbLogWriter .size () > maxLogSize ) {
        database.logger. setCheckpointRequired ();
    }
}\end{lstlisting}
这里会调用 dbLogWriter 对象（一个 ScriptWriterText 类实例）的 writeInsertStatement 方法。下面我们着重来分析和恢复有关的方法：
\begin{enumerate}
\item
\begin{lstlisting}
void open() {
    initParams();
    int state = properties.getDBModified();
    switch (state) {
        case HsqlDatabaseProperties.FILES_NEW :
            break;
        case HsqlDatabaseProperties.FILES_MODIFIED :
            database.logger.logInfoEvent("open start - state modified");
            deleteNewAndOldFiles();
            deleteOldTempFiles();
            if (properties.isVersion18()) {
                if (fa.isStreamElement(scriptFileName)) {
                    processScript();
                } else {
                    database.schemaManager.createPublicSchema();
                }
                HsqlName name = database.schemaManager.findSchemaHsqlName(
                    SqlInvariants.PUBLIC_SCHEMA);
                if (name != null) {
                    database.schemaManager.setDefaultSchemaHsqlName(name);
                }
            } else {
                processScript();
            }
            processLog();
            checkpoint();
            break;
        case HsqlDatabaseProperties.FILES_MODIFIED_NEW :
            database.logger.logInfoEvent("open start - state new files");
            renameNewDataFile();
            renameNewScript();
            deleteLog();
            backupData();
            properties.setDBModified(
                HsqlDatabaseProperties.FILES_NOT_MODIFIED);
        // continue as non-modified files
        // fall through
        case HsqlDatabaseProperties.FILES_NOT_MODIFIED :
            database.logger.logInfoEvent(
                "open start - state not modified");
            /**
             * if startup is after a SHUTDOWN SCRIPT and there are CACHED
             * or TEXT tables, perform a checkpoint so that the .script
             * file no longer contains CACHED or TEXT table rows.
             */
            processScript();
            if (!filesReadOnly && isAnyCacheModified()) {
                properties.setDBModified(
                    HsqlDatabaseProperties.FILES_MODIFIED);
                checkpoint();
            }
            break;
    }
    if (!filesReadOnly) {
        openLog();
    }
}\end{lstlisting}
这个方法用于打开日志。第 2 行初始化日志的基本参数。第 3 行获取数据库的修改状态，并分别处理：
\begin{itemize}
\item FILES\_NEW（新文件），直接跳转到第 54 行。
\item FILES\_MODIFIED（修改过），这表明数据库没有正常关闭，需要进行恢复。首先删除扩展名为.new 和.old 的遗留文件。然后删除临时文件。接下来判断数据库版本，对于当前版本，将执行 processScript 方法处理.script 文件。然后调用 processLog 方法处理 log 文件。最后执行 checkpoint 操作。
\item FILES\_MODIFIED\_NEW（修改过但是找不到 script 文件）对于这种情况，只能删除 log 文件，备份已有数据，接下来按未修改的情形处理。
\item FILES\_NOT\_MODIFIED（未修改）直接处理 script 文件，根据注释可知，还需要再额外执行 checkpoint 操作，以保证 script 文件中不包含 cached 或 text 表中的行。
调用 openLog 方法加载 log 文件，同时修改数据库状态为已修改。
\end{itemize}
\item checkpoint
\begin{lstlisting}
void checkpoint() {
    if (filesReadOnly) {
        return;
    }
    boolean result = checkpointClose();
    checkpointReopen();
    if (result) {
        database.lobManager.deleteUnusedLobs();
    } else {
        database.logger.logSevereEvent(
            "checkpoint failed - see previous error", null);
    }
}\end{lstlisting}
checkpoint 方法用于将所有脏数据写回。可以看到，这里的执行分两个阶段，分别是 checkpointClose 和 checkpointReopen。下面将分别分析这两个方法。
\item checkpointClose
\begin{lstlisting}
boolean checkpointClose () {
    ......
    deleteOldDataFiles ();
    try {
        writeScript ( false );
    } catch ( HsqlException e) {
        ......
    }
    try {
        if (cache != null ) {
            cache. commitChanges ();
            cache. backupFile ();
        }
    } catch ( Exception ee) {
        ......
    }
    ......
    deleteLog ();
    ......
    try {
        properties . setDBModified (
        HsqlDatabaseProperties . FILES_NOT_MODIFIED );
    } catch ( Exception e) {}
        ......
        return true ;
}\end{lstlisting}
第 3 行，删除.old 文件。 \\
第 5 行，调用 writeScript 方法，注意这里参数为 false，因此，对cached 和 text 表，只向 script 文件中写入 DDL 语句。\\
第 9-16 行调用 cache 的 commitChanges 方法，将数据写回磁盘，然后调用 backupFile 方法备份数据文件。\\
第 18 行删除日志文件。\\
第 21 行设置数据库属性为 FILES\_NOT\_MODIFIED。
经过这样的操作，脏数据被写入磁盘，同时 script 和 log 文件都成功更新。
\item checkpointReopen
\begin{lstlisting}
boolean checkpointReopen () {
    ......
    try {
        if (cache != null ) {
            cache. openShadowFile ();
        }
        if ( dbLogWriter != null ) {
            openLog ();
        }
        properties . setDBModified ( HsqlDatabaseProperties . FILES_MODIFIED );
    } catch ( Exception e) {
        return false ;
    }
    return true ;
}\end{lstlisting}
这个方法很简单，第 5 行打开数据文件，第 8 行打开日志文件，第 10 行设置数据库状态为已修改。
\item processScript
\begin{lstlisting}
private void processScript () {
    ScriptReaderBase scr = null ;
    try {
        Crypto crypto = database.logger. getCrypto ();
        if (crypto == null ) {
            boolean compressed = database.logger. propScriptFormat == 3;
            scr = new ScriptReaderText (database , scriptFileName ,
                compressed );
        } else {
            scr = new ScriptReaderDecode (database , scriptFileName , crypto ,
                false );
        }
        Session session =
            database. sessionManager . getSysSessionForScript (database );
        scr.readAll(session );
        scr.close ();
    } catch ( Throwable e) {
        ......
    }
}\end{lstlisting}
第 4-12 行获取 ScriptReader，这中间要判断文件是否加密、是否压缩。\\
第 14 行获取系统 session。\\
第 15 行调用 readAll 方法读取 script 文件，并在系统 session 中执行。readAll 方法由两条语句组成，分别是 readDLL 和readExistingData。
\item processLog
\begin{lstlisting}
private void processLog () {
    if (fa. isStreamElement ( logFileName )) {
        ScriptRunner . runScript (database , logFileName );
    }
}\end{lstlisting}
这里调用 ScriptRunner 类的静态方法 runScript 进行处理。
\item runScript
\begin{lstlisting}
private static void runScript(Database database, ScriptReaderBase scr) {
        ......
        try {
            StopWatch sw = new StopWatch();
            while (scr.readLoggedStatement(current)) {
                ......
                Result result = null;
                statementType = scr.getStatementType();
                switch (statementType) {
                    case ScriptReaderBase.ANY_STATEMENT :
                        statement = scr.getLoggedStatement();
                        Statement cs;
                        try {
                            cs = current.compileStatement(statement);
                            if (database.getProperties().isVersion18()) {
                                // convert BIT columns in .log to BOOLEAN
                                if (cs.getType()
                                        == StatementTypes.CREATE_TABLE) {
                                    Table table =
                                        (Table) ((StatementSchema) cs)
                                            .getArguments()[0];
                                    for (int i = 0; i < table.getColumnCount();
                                            i++) {
                                        ColumnSchema column =
                                            table.getColumn(i);
                                        if (column.getDataType().isBitType()) {
                                            column.setType(Type.SQL_BOOLEAN);
                                        }
                                    }
                                }
                            }
                            result = current.executeCompiledStatement(cs,
                                    ValuePool.emptyObjectArray, 0);
                        } catch (Throwable e) {
                            result = Result.newErrorResult(e);
                        }
                        ......
                        break;
                    case ScriptReaderBase.COMMIT_STATEMENT :
                        current.commit(false);
                        break;
                    case ScriptReaderBase.INSERT_STATEMENT : {
                        current.sessionContext.currentStatement = dummy;
                        current.beginAction(dummy);
                        Object[] data = scr.getData();
                        scr.getCurrentTable().insertNoCheckFromLog(current,
                                data);
                        current.endAction(Result.updateOneResult);
                        break;
                    }
                    case ScriptReaderBase.DELETE_STATEMENT : {
                        current.sessionContext.currentStatement = dummy;
                        current.beginAction(dummy);
                        Table           table = scr.getCurrentTable();
                        PersistentStore store = table.getRowStore(current);
                        Object[]        data  = scr.getData();
                        Row row = table.getDeleteRowFromLog(current, data);
                        if (row != null) {
                            current.addDeleteAction(table, store, row, null);
                        }
                        current.endAction(Result.updateOneResult);
                        break;
                    }
                    case ScriptReaderBase.SET_SCHEMA_STATEMENT : {
                        HsqlName name =
                            database.schemaManager.findSchemaHsqlName(
                                scr.getCurrentSchema());
                        current.setCurrentSchemaHsqlName(name);
                        break;
                    }
                    case ScriptReaderBase.SESSION_ID : {
                        break;
                    }
                }
                if (current.isClosed()) {
                    sessionMap.remove(currentId);
                }
            }
        } catch (HsqlException e) {
            ......
        } catch (OutOfMemoryError e) {
           ......
        } catch (Throwable e) {
            ......
        } finally {
            ......
        }
    }
}\end{lstlisting}
从上面代码可以看到，这里对每种语句进行分别处理：
\begin{itemize}
\item COMMIT：直接调用 session 的 commit 方法。
\item INSERT：调用表对象的 insertNoCheckFromLog 方法，该方法与前文提到的 insertData 方法相比，多了一个操作：记录插入这个 Action
\item DELETE：调用表对象的 deleteNoCheckFromLog 方法，该方法首先找到要删除的行，然后调用 addDeleteAction，这个方法在事务处理中已进行了分析。
\item SET SCHEMA：调用 session 的 setCurrentSchemaHsqlName 方法直接设置 Schema。
\item 其他语句：编译、运行即可。
\end{itemize}
\end{enumerate}
\section{问题总结}
\subsection{五个文件在恢复机制中分别有什么作用？}
\begin{itemize}
\item .properties：记录的数据库的一些设置属性，在恢复中，最重要的是 modified
属性，如果该属性为 yes，则意味着需要恢复。
\item .script：该文件记录了数据库表的定义，以及对于
memory table 的 insert 语句，在恢复前会和正常打开一样执行一次。
\item .data：该文件保存了 cached table 的数据，在恢复起始，它的数据
是崩溃前的最后一次 checkpoint 操作后记录的数据。在恢复后，数
据会被更新到正确的状态。
\item .backup：顾名思义，该文件是 .data 文件的备份。
\item .log：该文件是恢复机制的核心，记录了数据库最近的改变，checkpoint 到崩溃之间的所有操作。
\end{itemize}
\subsection{在插入或删除数据后，各数据文件有什么变化？}
插入或删除数据后，只有.log 文件发生了变化，.log 文件会记录这些操作。
\subsection{执行checkpoint后，各数据文件有什么变化？}
执行 checkpoint 后，.log 文件会被删除；.script 文件会被更新，对 memory table，.script 文件会记录所有的数据；和.data 文件也会被更新，保存当前的数据；.properties 文件的 modified 属性会被置为 no。
\subsection{cached table和memory table的数据分别是怎样恢复的？}
对于恢复操作，这两个表并没有明显区别，唯一的区别是，checkpoint后，对于 cached table，数据会被写回.data 文件，而对于 memory table，数据会被写回.script 文件。
\subsection{并发的事务如何恢复？}
事务是否并发与恢复并无关系，因为隔离级别保证了记录到日志中的操作均是正确的。因此，只要按照日志文件中的顺序进行恢复，就不会有问
题。
\subsection{未提交的事务是否恢复？}
未提交的事务不会记录在日志文件中，因此不会恢复。
%%%%%%%%% 参考文献 %%%%%%%%%%
\newpage
\end{document}
%%%%%%%%%% 结束 %%%%%%%%%%
